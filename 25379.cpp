#include <algorithm>
#include <bits/stdc++.h>
#include <stdio.h>
using namespace std;
// https://www.acmicpc.net/problem/25379
/*
피하자 서브태스크
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초 (추가 시간 없음)	1024 MB	6234	1817	1320	31.103%
문제
음이 아닌 정수로 이루어진 길이 N의 배열 A = [A1, A2, · · · , AN]가 있다. 배열
A에서 인접한 두 수를 교환하는 시행을 원하는 만큼 할 수 있다. 이 때, 홀수와
짝수가 인접한 경우가 최대 1번 등장하도록 하는 시행의 최소 횟수를 구하여라. 단, 0
또한 짝수로 간주함에 유의하라.

예를 들어, 아래 그림과 같이 A = [4, 5, 1, 0]인 상황을 살펴보자. 이 경우, 마지막
두 원소를 교환하는 시행 과 가운데 두 원소를 교환하는 시행을 차례로 수행하면 A가
[4, 0, 5, 1]이 되어 홀수와 짝수가 인접한 경우가 최대 1번 등장하도록 할 수 있다.


입력
첫 번째 줄에 정수 N이 주어진다.

두 번째 줄에 배열의 원소 A1, A2, · · · , AN이 사이에 공백을 두고 주어진다.

출력
첫 번째 줄에 답을 출력한다.

제한
1 ≤ N ≤ 1 000 000.
0 ≤ Ai ≤ 2 × 109 (1 ≤ i ≤ N).
Ai는 정수이다.
서브태스크
번호	배점	제한
1	10
N ≤ 3.

2	40
N ≤ 1 000.

3	50
추가 제약 조건 없음.

예제 입력 1
1
1
예제 출력 1
0
예제 입력 2
4
4 5 1 0
예제 출력 2
2
예제 입력 3
4
1 2 3 1
예제 출력 3
1



111...10...000 꼴 혹은 000...01...111 꼴로 정렬하는 문제
직접 다 돌리는건 오래걸려서 안될거 같고
i<j, Ai > Aj면 Ai = 1, Aj = 0을 만족하니까
j에 대해서 자기보다 앞에있는 1의 개수의 합만큼이 (i,j) 의 순서쌍의 개수임
그니까 개수 체크 양쪽다 해보고 더 작은쪽 출력하면 됨
*/

int main() {
  int N, A[1010101];
  long long R = 1e18;
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cin >> N;
  for (int i = 1; i <= N; i++)
    cin >> A[i], A[i] %= 2;              // 0 1 로 받기
  for (int iter = 0; iter < 2; iter++) { // 오름차수 내림차수
    long long cnt = 0, acc = 0;
    for (int i = 1; i <= N; i++) {
      if (A[i] == iter)
        acc += 1;
      else
        cnt += acc;
    }
    R = min(R, cnt); // 오름차수 내림차수 둘중에 더 작은거
  }
  cout << R;
}
